{"name":"plz","tagline":"build automation","body":"<img src=\"https://github.com/robey/plz/raw/master/docs/images/plz.png\" width=\"80\">\r\n\r\n[![Build Status](https://travis-ci.org/robey/plz.png?branch=master)](https://travis-ci.org/robey/plz)\r\n\r\n![Install](https://nodei.co/npm/plz.png?compact=1)\r\n\r\nPlz is a script automation system like \"make\", \"rake\", and \"cake\". It aims to\r\nmake simple tasks trivial, and difficult tasks easier. Highlights:\r\n\r\n- No waiting for a JVM to launch. Rules are written in coffeescript (or\r\n  javascript) and executed by the (fast) v8 engine. \r\n- No console spew. The default logging level runs silent unless there's an\r\n  error.\r\n- Most of the basic shell commands are exposed as global functions via\r\n  shelljs (https://github.com/arturadib/shelljs), or just call \"exec\".\r\n- Tasks can depend on other tasks, attach themselves before/after other\r\n  tasks, or they can be run automatically when a file changes, based on glob\r\n  patterns.\r\n\r\n### Table of contents\r\n\r\n- [Install](#install)\r\n- [Example](#example)\r\n- [How it works](#how-it-works)\r\n- [Defining tasks](#defining-tasks)\r\n- [File watches](#file-watches)\r\n- [Globals](#globals)\r\n- [exec](#exec)\r\n- [Settings](#settings)\r\n- [Before and after tasks](#before-and-after-tasks)\r\n- [Plugins](#plugins)\r\n- [Manifesto](#manifesto)\r\n- [Developing](#developing)\r\n- [License](#license)\r\n- [Authors](#authors)\r\n- [Thanks](#thanks)\r\n\r\n\r\nInstall\r\n-------\r\n\r\nMake sure you have node installed (http://nodejs.org/), then:\r\n\r\n```sh\r\n$ sudo npm install -g plz\r\n```\r\n\r\n\r\nExample\r\n-------\r\n\r\nHere's a sample `build.plz` rules file that says:\r\n\r\n- for \"build\", compile coffeescript from `src/` to `lib/`\r\n- whenever anything in `lib/` changes, run the (mocha) tests again\r\n\r\nSince it's just a normal script, we pull out the coffee & mocha binaries to\r\nthe top, in case we need to change them later.\r\n\r\n```coffeescript\r\ncoffee = \"./node_modules/coffee-script/bin/coffee\"\r\nmocha = \"./node_modules/mocha/bin/mocha\"\r\n\r\ntask \"build\", description: \"compile coffeescript\", run: ->\r\n  mkdir \"-p\", \"lib\"\r\n  exec \"#{coffee} -o lib -c src\"\r\n\r\ntask \"test\", description: \"run unit tests\", watch: \"lib/**/*\", run: (options) ->\r\n  display = options.display or \"spec\"\r\n  exec \"#{mocha} -R #{display} --compilers coffee:coffee-script --colors\"\r\n```\r\n\r\nYou can run plz alone, which will find the `build.plz` and run the default\r\nrule (`build`):\r\n\r\n```sh\r\n$ plz\r\n```\r\n\r\nor you can run tests alone, choosing the dot display:\r\n\r\n```sh\r\n$ plz test display=dot\r\n```\r\n\r\nAs another example, this script pushes my (staging) website whenever I make\r\na change on my laptop:\r\n\r\n```javascript\r\ntask(\"build\", { watch: \"./**/*\", run: function() {\r\n  mark();\r\n  exec(\"rsync -avP ./ example.com:/web/leet/staging/\");\r\n}});\r\n```\r\n\r\nWhen run with the \"-w\" (watch) option:\r\n\r\n```sh\r\n$ plz -w\r\n```\r\n\r\nit monitors the current folder. Whenever a file is modified, it displays the\r\ncurrent time (that's what `mark()` does) and calls rsync.\r\n\r\n\r\nHow it works\r\n------------\r\n\r\nWhen you launch plz, it takes the list of tasks from the command line. If no\r\ntasks were listed, it will use a default task list that contains only \"build\".\r\n\r\nIf a rule file is specified on the command line (via `-f`), or via the\r\nenvironment variable `PLZ_RULES`, then the tasks are loaded from that file. If\r\nnot, plz looks in the current folder for a \"build.plz\" file. If there's not\r\none in the current folder, it looks in the parent folder, and so on up the\r\ntree.\r\n\r\nFor each task you asked it to run, plz looks up the dependencies from the\r\n`must` field, and sorts them (topologically) so that the deepest dependencies\r\ncome first. Chains of dependencies are followed, but cycles aren't allowed.\r\nThese are all then enqueued, uniquely, so that no task is enqueued twice.\r\n\r\nPlz then runs each task in the queue, one at a time, in order, until there's\r\nan error or the queue is finished.\r\n\r\nWhen it's done running the queue, plz checks if any task's file watches were\r\ntriggered. If so, those tasks (and their dependencies) are enqueued and it\r\nstarts over again. This continues until the tasks in the queue can all be run\r\nwithout triggering any more file watches.\r\n\r\nNormally, plz will then exit.\r\n\r\nIf it's running in `--watch` (`-w`) mode, plz will block instead, waiting for\r\nfile watches to trigger, until killed (usually by hitting control-C).\r\n\r\nThe `--verbose` (`-v`) option will make plz display the names of tasks as it\r\nexecutes them. `--debug` will make it dump more detailed debugging info about\r\nfile watches and internal state.\r\n\r\n\r\nDefining tasks\r\n--------------\r\n\r\nTasks are defined with the `task` function:\r\n\r\n```coffeescript\r\ntask(name, options)\r\n```\r\n\r\nIf a task returns a promise (such as by calling `exec` -- see below), the task\r\nexecution will \"block\" and not run any further tasks until the promise is\r\nfulfilled, or finished.\r\n\r\nThe options are:\r\n\r\n- `description`: a help line to be displayed for `--help` or `--tasks`\r\n- `must`: list of tasks that this task depends on\r\n- `watch`/`watchall`: list of file globs that will cause this task to run\r\n- `before`/`after`/`attach`: combine this rule with another existing rule\r\n- `run`: the actual code to run for this task\r\n\r\n\r\nFile watches\r\n------------\r\n\r\nA task can be executed automatically (or technically: enqueued to be executed)\r\nwhen file changes are detected. A watch list is a string or array of strings\r\npassed as the `watch` or `watchall` option to `task`. The strings are globs in\r\nthe style of the `glob` and `globwatcher` modules, so wildcards like `*`, `?`,\r\nand `**` have their usual behavior.\r\n\r\nA `watch` is triggered whenever a file matching that glob is created or\r\nmodified. Modified files are detected by size changes or \"modification time\"\r\nchanges -- but be aware that some operating systems like OS X and Windows only\r\ntrack file modification times to the nearest second (or two seconds on\r\nWindows).\r\n\r\nA `watchall` is additionally triggered when any file matching that glob is\r\ndeleted. Usually you don't want this mode, because if you have a \"clean\" task\r\nthat deletes files, it may trigger build tasks, with unexpected (but\r\nhilarious) results.\r\n\r\n\r\nGlobals\r\n-------\r\n\r\nThe following globals are available to tasks:\r\n\r\n- `task(name, options)`: create a new task\r\n- `runTask(name)`: queue up a task to run\r\n- `settings`: global settings object (see \"settings\" below)\r\n- `project`: object with project details:\r\n    - `name`: name of the project (usually just the current folder name)\r\n    - `type`: a string describing the project type, if a plugin has identified the project\r\n- shell commands from [shelljs](https://github.com/arturadib/shelljs):\r\n    - cat, cd, chmod, cp, dirs, echo, env, exit, find, grep, ls, mkdir, mv, popd, pushd, pwd, rm, sed, test, which\r\n- `exec(command, options)`: see \"exec\" below\r\n- `touch(filename)` which is `touch.sync` from [node-touch](https://github.com/isaacs/node-touch)\r\n- node builtins and the Q promises library:\r\n    - console\r\n    - process\r\n    - Buffer\r\n    - Q\r\n- logging functions, which take a string to log:\r\n    - `debug(text)` (displayed with `--debug`)\r\n    - `info(text)` (displayed with `--verbose`)\r\n    - `notice(text)`\r\n    - `warning(text)`\r\n    - `error(text)`\r\n    - `mark()` (to quickly log the current date/time)\r\n- `plz` object containing global state functions:\r\n    - `useColors()`: get or set `--color`\r\n    - `logVerbose()`: get or set `--verbose`\r\n    - `logDebug()`: get or set `--debug`\r\n    - `version()`: current plz version\r\n    - `cwd()`: get or set the current folder\r\n    - `rulesFile()`: get or set the name of the plz rules file (usually \"build.plz\")\r\n- `load(pluginName)`: loads a plugin (see \"plugins\" below)\r\n- `plugins`: object that maps plugin names to functions (see \"plugins\" below)\r\n\r\n\r\nexec\r\n----\r\n\r\nThe `exec` function is a lightweight wrapper around node's `spawn` function.\r\n\r\n```coffeescript\r\nexec(command, options)\r\n```\r\n\r\nIf the command is a single string, it's passed to a nested shell. If it's an\r\narray, it's passed directly to `spawn`. The options are the same as for\r\n`spawn`, with sensible defaults.\r\n\r\n`exec` returns a promise which will be fulfilled with a success or failure,\r\nbut doesn't block. If you call exec twice in a row, *both commands will run at\r\nthe same time*. This is a limitation of node -- there's currently no way to\r\nspawn a process in a blocking way. You can work around this by chaining the\r\npromises:\r\n\r\n```coffeescript\r\nexec \"something\".then ->\r\n  exec \"something else\"\r\n```\r\n\r\n\r\nSettings\r\n--------\r\n\r\nA global `settings` object is available to tasks for configuration. Each field\r\nin this object is either a string, or a nested object (to allow for namespaced\r\nsettings). They're loaded in this order:\r\n\r\n1. Any javascript/coffeescript global code in the rules file (or plugins or\r\n   loaded modules) will run first. Usually this is used to set default values.\r\n\r\n2. If the file `$HOME/.plzrc` exists, or the environment variable `PLZRC` is\r\n   set, that file is loaded. It should contain `key=value` pairs, one per\r\n   line. Blank lines and comments (lines starting with \"#\") are allowed.\r\n\r\n3. Finally, any `key=value` pairs on the command line will take effect.\r\n\r\nFor `key=value` pairs, the key can be a dotted path like \"mocha.display\" to\r\naccess the nested field \"display\" on the settings object \"mocha\". Plugins use\r\ndotted paths for namespacing.\r\n\r\nA \"project\" setting is created by default, with two properties:\r\n\r\n- `name`: the name of the project folder\r\n- `type`: \"basic\"\r\n\r\nPlz doesn't use this setting itself, but plugins may add more info, or change\r\nthe type. For example, a coffeescript plugin might set the type to\r\n\"coffeescript\" to indicate to other plugins and tasks that this is primarily a\r\ncoffeescript project.\r\n\r\n\r\nBefore and after tasks\r\n----------------------\r\n\r\nA task can ask to run before or after some other task, like:\r\n\r\n```coffeescript\r\ntask \"prebuild\", before: \"build\", run: ->\r\n  # perform some setup work\r\n```\r\n\r\nThese \"barnacle\" tasks won't appear in the task list for `--help` or\r\n`--tasks`. They're combined with the task they're modifying. So in this case,\r\nthe \"build\" task will run the setup work defined in \"prebuild\" before running\r\nits own code.\r\n\r\nHere's another example, which will print the letters A, B, C in order when the\r\ntask \"hello\" is executed:\r\n\r\n```coffeescript\r\ntask \"hello\", run: -> notice \"B\"\r\ntask \"pre-hello\", before: \"hello\", run: -> notice \"A\"\r\ntask \"post-hello\", after: \"hello\", run: -> notice \"C\"\r\n```\r\n\r\nA task can also \"attach\" to another task, like this:\r\n\r\n```coffeescript\r\ntask \"build-coffee\", attach: \"build\", description: \"compile coffee-script source\", run: ->\r\n  mkdir \"-p\", \"lib\"\r\n  exec \"coffee -o lib -c src\"\r\n```\r\n\r\nAttached tasks work exactly the same as \"after\", but they don't require the\r\noriginal task to exist. In the above example, if the \"build\" task was never\r\ndefined, plz will make an empty \"build\" task to attach to. This is mostly a\r\nconvenience for plugins to add code to common targets like \"build\" and \"test\".\r\n\r\n\r\nPlugins\r\n-------\r\n\r\nPlugins are code that can be loaded into your build rules to define new tasks\r\nor settings. Usually they add support for a specific language or tool. For\r\nexample, to load support for mocha (a javascript test system):\r\n\r\n```coffeescript\r\nload \"mocha\"\r\n```\r\n\r\nThe \"load\" function first looks in the global object \"plugins\" for a property\r\nwith the name of the requested module. If it exists, it's called as a\r\nfunction. This lets a script define multiple plugins by adding functions to\r\nthe \"plugins\" object, which delayes execution of the code until the plugin is\r\nexplicitly loaded via \"load\".\r\n\r\nIf there's no property in the \"plugins\" object, plz will try to load a\r\njavascript or coffeescript file with one of the following names (where `NAME`\r\nis the name passed to \"load\"):\r\n\r\n- `plz-NAME.js`\r\n- `plz-NAME.coffee`\r\n- `plz-NAME/index.js`\r\n- `plz-NAME/index.coffee`\r\n\r\nIt searches these folders, in order:\r\n\r\n1. `$HOME/.plz/plugins/`\r\n2. `$PROJECT/.plz/plugins/` (the current project folder)\r\n3. `PLZ_PATH` if it's defined\r\n4. the normal node search path\r\n\r\nPlugins are executed in the same namespace as the build script, so they can\r\nmodify globals. (This is unusual in coffeescript, but normal in javascript.)\r\n\r\nHere's an example plugin that adds mocha support:\r\n\r\n```coffeescript\r\nextend settings,\r\n  mocha:\r\n    bin: \"./node_modules/mocha/bin/mocha\"\r\n    display: \"spec\"\r\n    grep: null\r\n    options: [ \"--colors\" ]\r\n\r\ntask \"test-mocha\", attach: \"test\", description: \"run unit tests\", run: ->\r\n  if settings.mocha.grep? then settings.mocha.options.push \"--grep #{settings.mocha.grep}\"\r\n  exec \"#{settings.mocha.bin} -R #{settings.mocha.display} #{settings.mocha.options.join(' ')}\"\r\n```\r\n\r\nIt adds a few settings to the \"mocha\" namespace to allow overridding (for\r\nexample, by passing \"mocha.display=nyan\" on the command line), and attaches\r\nsome code to the \"test\" task so that mocha tests are run whenever \"test\" is\r\nexecuted.\r\n\r\n\r\nManifesto\r\n---------\r\n\r\nWhy does this even exist?\r\n\r\n\"Make\" is 1000 years old, and somehow still the gold standard of build\r\nautomation. \"Ant\" was an embarrassment; \"Maven\" thought maybe the problem with\r\nant was that it didn't have enough bureaucracy; both conflate builds with\r\npackage management. The high-level language world is on the right track with\r\nthings like \"rake\" and \"cake\", but they aren't flexible enough to grow with\r\nyou when you need to do more than just run a few shell commands.\r\n\r\nYou should be able to write some simple rules to describe how to build your\r\nlibrary or app or website, and those rules shouldn't require you to learn a\r\nnew language. It should be basically a list of shell commands, with some\r\njavascript/coffeescript code if you want to get fancy, and it should run\r\nautomatically when watched files are changed.\r\n\r\nIn short, you should be able to automate command pipelines without getting\r\nbogged down in \"frameworks\" or trying to figure out how to read an environment\r\nvariable or copy a file. Shell commands have been able to do this -- and so\r\nhave you -- since you were a kitten.\r\n\r\n\r\nDeveloping\r\n----------\r\n\r\nInstall dependencies using node, then build with a current version of plz:\r\n\r\n    $ npm install\r\n    $ plz\r\n\r\nPull requests and bug reports are tracked on github:\r\nhttps://github.com/robey/plz\r\n\r\n\r\nLicense\r\n-------\r\n\r\nApache 2 (open-source) license, included in 'LICENSE.txt'.\r\n\r\n\r\nAuthors\r\n-------\r\n\r\n- @robey - Robey Pointer <robeypointer@gmail.com>\r\n\r\n\r\nThanks\r\n------\r\n\r\n- @azer for introducing me to the idea of having file triggers launch tasks.\r\n- @dbrock for letting me use the name on npm.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}